# 인증 로직 호환성 분석 및 해결방안

## 📋 현재 상황 요약

HR 관리 시스템에서 클라이언트 사이드 인증(`useAuth.ts`)과 서버 사이드 미들웨어(`middleware.ts`) 간의 호환성 문제가 발생하고 있습니다.

## 🔍 주요 문제점 분석

### 1. **인증 상태 동기화 문제**

#### 클라이언트 사이드 (`useAuth.ts`)
```typescript
// React Hook으로 브라우저에서만 실행
const { data: { session }, error } = await supabase.auth.getSession()
```

#### 서버 사이드 (`middleware.ts`)
```typescript
// Next.js 미들웨어로 서버에서 실행
const supabase = createMiddlewareClient({ req: request, res })
const { data: { session }, error } = await supabase.auth.getSession()
```

**문제점**: 클라이언트와 서버가 서로 다른 Supabase 클라이언트 인스턴스를 사용하여 인증 상태가 동기화되지 않음

### 2. **쿠키 관리 불일치**

#### 현재 미들웨어의 쿠키 처리
```typescript
// 여러 쿠키 이름을 시도하는 복잡한 로직
const possibleCookieNames = [
  `sb-${process.env.NEXT_PUBLIC_SUPABASE_URL?.split('//')[1]?.split('.')[0]}-auth-token`,
  'sb-access-token', 
  'sb-refresh-token',
  'supabase-auth-token'
]
```

**문제점**: 
- Supabase의 표준 쿠키 네이밍 규칙과 불일치
- 실제 쿠키 이름: `sb-[project-ref]-auth-token`
- 복잡한 fallback 로직으로 인한 성능 저하

### 3. **임시 해결책으로 인한 보안 취약점**

```typescript
// 🚨 현재 미들웨어가 완전히 비활성화됨
const DISABLE_MIDDLEWARE_AUTH = true
```

**문제점**: 
- 모든 라우트 보호 기능이 비활성화
- 인증되지 않은 사용자도 보호된 페이지 접근 가능
- 보안상 매우 위험한 상태

### 4. **Supabase Auth Helpers 버전 호환성**

#### 현재 사용 중인 패키지
```typescript
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
```

**문제점**: 
- `@supabase/auth-helpers-nextjs`는 deprecated 상태
- 최신 Supabase SSR 패키지와 호환성 문제
- 쿠키 설정 및 세션 관리 방식의 차이

## 🛠️ 해결방안

### 1. **Supabase SSR 패키지로 마이그레이션**

#### 패키지 업데이트
```bash
npm uninstall @supabase/auth-helpers-nextjs
npm install @supabase/ssr
```

#### 새로운 미들웨어 구조
```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value,
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value,
            ...options,
          })
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value: '',
            ...options,
          })
        },
      },
    }
  )

  const { data: { user } } = await supabase.auth.getUser()
  
  // 인증 로직 처리...
  
  return response
}
```

### 2. **클라이언트 사이드 Supabase 클라이언트 업데이트**

#### 새로운 `lib/supabase.ts` 구조
```typescript
import { createBrowserClient } from '@supabase/ssr'

export const supabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)
```

### 3. **통합된 인증 상태 관리**

#### Context Provider 도입
```typescript
// contexts/AuthContext.tsx
'use client'

import { createContext, useContext, useEffect, useState } from 'react'
import { User, Session } from '@supabase/supabase-js'
import { supabase } from '@/lib/supabase'

interface AuthContextType {
  user: User | null
  session: Session | null
  loading: boolean
  signOut: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [session, setSession] = useState<Session | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // 초기 세션 확인
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session)
      setUser(session?.user ?? null)
      setLoading(false)
    })

    // 인증 상태 변화 감지
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        setSession(session)
        setUser(session?.user ?? null)
        setLoading(false)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  const signOut = async () => {
    await supabase.auth.signOut()
  }

  return (
    <AuthContext.Provider value={{ user, session, loading, signOut }}>
      {children}
    </AuthContext.Provider>
  )
}

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}
```

### 4. **라우트 보호 로직 개선**

#### 간소화된 미들웨어
```typescript
export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  
  // 정적 파일 및 API 라우트 제외
  if (pathname.startsWith('/_next') || 
      pathname.startsWith('/api') || 
      pathname.includes('.')) {
    return NextResponse.next()
  }

  const response = NextResponse.next()
  const supabase = createServerClient(/* ... */)
  
  const { data: { user } } = await supabase.auth.getUser()
  const isAuthenticated = !!user

  // 보호된 라우트 체크
  const protectedRoutes = ['/employees', '/payroll', '/profiles', '/schedule', '/stores', '/help', '/test']
  const isProtectedRoute = protectedRoutes.some(route => pathname.startsWith(route))

  if (isProtectedRoute && !isAuthenticated) {
    const redirectUrl = new URL('/login', request.url)
    redirectUrl.searchParams.set('from', pathname)
    return NextResponse.redirect(redirectUrl)
  }

  if (pathname === '/login' && isAuthenticated) {
    return NextResponse.redirect(new URL('/profiles', request.url))
  }

  if (pathname === '/' && isAuthenticated) {
    return NextResponse.redirect(new URL('/profiles', request.url))
  }

  if (pathname === '/' && !isAuthenticated) {
    return NextResponse.redirect(new URL('/landing', request.url))
  }

  return response
}
```

## 📋 구현 단계별 체크리스트

### Phase 1: 패키지 업데이트
- [ ] `@supabase/auth-helpers-nextjs` 제거
- [ ] `@supabase/ssr` 설치
- [ ] 환경변수 확인 및 설정

### Phase 2: 서버 사이드 리팩토링
- [ ] 새로운 `middleware.ts` 구현
- [ ] 쿠키 처리 로직 개선
- [ ] 라우트 보호 로직 간소화

### Phase 3: 클라이언트 사이드 리팩토링
- [ ] `lib/supabase.ts` 업데이트
- [ ] `AuthContext` 구현
- [ ] 기존 `useAuth.ts` 마이그레이션

### Phase 4: 테스트 및 검증
- [ ] 로그인/로그아웃 플로우 테스트
- [ ] 보호된 라우트 접근 테스트
- [ ] 세션 지속성 테스트
- [ ] 브라우저 새로고침 시 상태 유지 테스트

## ⚠️ 주의사항

1. **점진적 마이그레이션**: 한 번에 모든 것을 변경하지 말고 단계별로 진행
2. **백업**: 기존 코드를 백업한 후 작업 시작
3. **테스트**: 각 단계마다 철저한 테스트 수행
4. **환경변수**: Supabase 프로젝트 설정 확인 필수

## 🎯 예상 효과

- ✅ 클라이언트-서버 간 인증 상태 동기화
- ✅ 표준 Supabase SSR 패턴 적용
- ✅ 보안 강화 (라우트 보호 기능 복원)
- ✅ 성능 개선 (불필요한 쿠키 체크 로직 제거)
- ✅ 유지보수성 향상 (최신 패키지 사용)

## 📚 참고 자료

- [Supabase SSR 공식 문서](https://supabase.com/docs/guides/auth/server-side/nextjs)
- [Next.js 미들웨어 가이드](https://nextjs.org/docs/app/building-your-application/routing/middleware)
- [Supabase Auth Helpers 마이그레이션 가이드](https://supabase.com/docs/guides/auth/server-side/migrating-to-ssr-from-auth-helpers)
